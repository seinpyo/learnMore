
## 엔티티 직접 사용
    - JPQL에서 엔티티를 직접 사용하면 SQL에서 해당 엔티티의 기본 키 값을 사용
        select count(m.id) from member m
        select count(m) from Member m
         -> JPQL 둘다 같은 SQL 실행


## Named 쿼리 - 어노테이션
    - 쿼리를 미리 정의해서 이름을 부여해두고 사용
    - 정적 쿼리만 사용 가능
    - 어노테이션, xml에 정의 가능
    - 애플리케이션 로딩 시점에 초기화 후 재사용한다 -> 애플리케이션 로딩 시점에 쿼리를 검증 (쿼리에 오류가 있으면 컴파일 시 에러 터짐)


## 벌크 연산
    - 조건을 만족하는 모든 row 의 update나 delete
    - JPA 변경 감지 기능으로 실행하기에 너무나 많은 SQL 실행
    - 벌크 연산은 영속성 컨텍스트를 무시하고 db에 직접 쿼리
        ->  5000원 짜리 물건을 조회 후 벌크연산을 통해 6000원으로 수정
            -> 데이터베이스에 직접 쿼리하기 때문에 db에는 6000원인데 영속성 콘텍스트에는 5000원인 상황
            * 해결 방안
            1) 영속성 컨텍스트에 암것도 없는 상태에서 벌크 연산을 먼저 수행
            2) 벌크 연산 한 후 영속성 컨텍스트를 초기화