
## 상속관계 매핑
    - RDBMS에는 상속관계가 없음
    - 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법
        - 조인전략: 자식, 부모테이블을 각각 따로 만들고 join 으로 값을 가져옴
            - @Inheritance(strategy = InheritanceType.JOINED)
            - 장점: 가장 정규화된 방법, 외래 키 참조 무결성 제약 조건 활용 가능, 저장 공간 효율화
            - 단점: 조회 시 조인을 많이 사용 (=성능 저하), 조회 쿼리 복잡, 데이터 저장 시 insert 쿼리 2회 호출

        - 단일 테이블 전략: 자식,부모 컬럼을 다 모아서 하나의 테이블로 만듦
            - @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
            - 장점: 조인 필요 x (= 조회 성능 좋음), 조회 쿼리 단순
            - 단점: 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 함(데이터 무결성 저하),
                단일 테이블에 모두 다 저장하므로 테이블이 커질 수 있어 조회 성능이 떨어질 수 있다.

        - 구현 클래스마다 테이블 전략: 자식테이블만 만들고 중복된 컬럼을 테이블마다 가짐
            - @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
            - 쓰지마시오
            - 장점: 서브 타입을 명확하게 구분해서 처리할 때 효과적, not null 제약 조건 사용 가능
            - 단점: 여러 자식 테이블과 함께 조회할 때 성능 느림(union all), 자식 테이블 통합해서 쿼리 하기 어렵다

## MappedSuperclass
    - 공통 매핑 정보가 필요할 때 사용
    - 주로 등록일, 수정이르 등록자, 수정자 같은 전체 엔티티에서 공통적으로 적용하는 정모를 모을 때 사용
    - 테이블이 생성되는 게 아님. 부모 클래스를 상속 받는 자식 클래스에 "매핑 정보"만 제공
    - 조회 검색 불가, em.find(MappedSuperclass.class) -> 처럼 사용 할 수 x
    - 추상 클래스 권장
    - @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속이 가능하다.