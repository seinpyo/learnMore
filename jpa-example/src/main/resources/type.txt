## JPA 데이터 타입 분류
    - 엔티티타입: @Entity 로 정의, 식별자 o, 데이터가 변해도 식별자로 추적가능
    - 값타임: int, String 등 단순한 값으로 사용하는 자바 기본 타입이나 객체. 식별자 x
        - 자바 기본타입, 래퍼클래스, String
            -생명주기를 엔티티의 의존(회원 삭제 시, 이름 필드도 함께 삭제), 공유하면 안됨
        - 임베디드 타입(복합 값 타입): ex) 좌표(x,y) 등을 정의해서 사용
            - @Embeddable, @Embedded
            - 기본 생성자 필수
            - 재사용 가능, 높은 응집도, 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음
            - 임베디드 타입을 사용하기 전 후에 매핑하는 테이블은 같다 (변하지 않는다)
            - 잘 설계한 ORM 애플리케이션은 매핑한 테이블 수보다 클래스의 수가 더 많다
            ** @AttributeOverride : 한 엔티티에서 같은 값 타입을 사용할 때(ex -  Member 테이블에서 Address 타입으로 집주소/회사주소 를 매핑)
            - 임베디드 타입의 값이 null 이면 매핑한 컬럼 값은 모두 null (ex - Address=null 상태로 Member 테이블에 insert하면 city, street, zipcode가 null로 저장됨 )
        - 컬렉션 값 타입

## 값 타입과 불변 객체
    - 임베디드 타입과 같은 값 타입을 여러 엔티티에서 공유하면 위험! (부작용 발생)
    - 항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 막을 방법이 x
    - 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입임
        - 기본 타입에 값을 대입하면 값을 복사하지만 객체 타입은 참조 값을 직접 대입한다
        = 객체의 공유 참조를 피할 수 없다
        ex) int a = 100; int b = a; a = 50;  ==> a = 100; b = 50;
        ex2) Address home = new Address("서울시", "이런로", "12345");
             Address work = home; work.setStreet("저런로");
            ==> home = ("서울시", "저런로", "12345"); company = ("서울시", "저런로", "12345");
        ** home만 바꾸고 싶었지만 그렇게는 안됨 (참조 값을 직접 대입하기 때문)

        -> 불변 객체 : 생성 시점 이후 절대 값을 변경할 수 x
        = 생성자로만 값을 설정하고 수정자(setter)를 안만들면 됨
        (cf: Integer와 String은 자바가 제공하는 대표적인 불변 객체)

        ※※ 값 타입은 불변 객체로 만들자

## 값 타입의 비교
    - a.equals(b) 를 사용해서 동등성 비교를 해야함
    - equals() 메서드의 기본은 a==b 기 때문에 메서드를 적절하게 재정의 해야 함 (주로 모든 필드를 다 재정의)